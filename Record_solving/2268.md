2268 : 수들의 합 7
========
https://www.acmicpc.net/problem/2268

***

### Problem information

> Tier : <span style="color:orange">__Gold 1__</span>
> 
> Tag : __Segment Tree__, __Data Structure__
> 
> Language : <span style="color:skyblue">__C++__</span>

***

### Description

구간합을 구하는 Sum 함수와, 특정 인덱스의 값을 변경하는 Modify 함수를 구현하는 문제다.

세그먼트 트리의 기본 문법을 되살리기 위해서 풀었는데, update 함수가 단일 값 변경만 해서 큰 문제는 없었던 것 같다.

트리의 높이 h를 구할때는 항상 for문을 사용해왔었는데, 사실 log2 를 사용하면 바로 해결이 가능하다는 것을 알게 되었다.

(배열의 길이 n은 `2^(h - 2)` 초과 `2^(h - 1)`이하기 때문)

---

### What I learned

- 세그먼트 트리의 기초 구현 복습 (Sum, Init, Update)
- 트리의 높이 h는 기존 배열의 크기 n에 대해서 `h = ceil(log2(n))` 으로 구할 수 있음
- 세그트리의 높이가 h일때 배열로 구현하는 세그먼트 트리의 크기는 `2^(h + 1)`이며, 이는 `1 << (h + 1)`로 구현 가능하다

---

### Next Learning Plan

- 여러개의 값을 동시에 변경하는 Segment tree의 Update 함수
- Lazy propagation

---

### Code (C++)

```c++
#include <iostream>
#include <vector>
#include <cmath>
typedef long long ll;
using namespace std;

int cal_tree_size(int vector_size) {
    int h = ceil(log2(vector_size));
    return (1 << (h + 1));
}

void input_vector(vector<int> &origin_vector, int vector_size) {
    for(auto &i : origin_vector) cin >> i;
}

ll seg_init(const vector<int> &origin, vector<ll> &tree, int node, int left, int right) {
    if(left >= right) return 0;

    if(right - left == 1) {
        tree[node] = origin[left];
        return tree[node];
    }

    int mid = (left + right) / 2;

    ll left_value = seg_init(origin, tree, node * 2, left, mid);
    ll right_value = seg_init(origin, tree, node * 2 + 1, mid, right);

    tree[node] = left_value + right_value;
    return tree[node];
}

void seg_update(const vector<int> &origin, vector<ll> &tree, int node, int left, int right, int idx, int diff) {
    if(idx < left or right <= idx) return;

    tree[node] += diff;
    if(left + 1 == right) return;

    int mid = (left + right) / 2;
    seg_update(origin, tree, node * 2, left, mid, idx, diff);
    seg_update(origin, tree, node * 2 + 1, mid, right, idx, diff);
}

ll seg_sum(const vector<int> &origin, vector<ll> &tree, int node, int left, int right, int start, int end) {
    if(right <= start or left >= end) return 0;
    if(start <= left and right <= end) return tree[node];

    int mid = (left + right) / 2;
    ll left_value = seg_sum(origin, tree, node * 2, left, mid, start, end);
    ll right_value = seg_sum(origin, tree, node * 2 + 1, mid, right, start, end);

    return left_value + right_value;
}

void solve() {
    int n;
    int m;
    int tree_size;
    cin >> n >> m;
    n++;

    tree_size = cal_tree_size(n);

    vector<int> origin_vector(n);
    for(auto &i : origin_vector) i = 0;
    vector<ll> seg_tree(tree_size);
    seg_init(origin_vector, seg_tree, 1, 1, n + 1);

    int order, start, end, point, value;
    for(int i = 0; i < m; i++){
        cin >> order;
        if(order == 0){
            cin >> start >> end;
            if(start > end) {
                swap(start, end);
            }

            cout <<
            seg_sum(origin_vector, seg_tree, 1, 1, n + 1, start, end + 1)
            << '\n';
        }
        else {
            cin >> point >> value;
            int diff = value - origin_vector[point];
            origin_vector[point] = value;
            seg_update(origin_vector, seg_tree, 1, 1, n + 1, point, diff);
        }
    }

}

//-------------------------------------------- const code ------------------------------------------
//int main() {
//    ios_base::sync_with_stdio(false);
//    cin.tie(nullptr); cout.tie(nullptr);
//
//    solve();
//
//    return 0;
//}

```